---
title: Functional Programming
description: >
  제대로 좀 하자구~
sitemap: false
permalink: /frontend/fp
---

### Chapter 4

- Actions
    - 전역 변수 (변경 가능하기 때문)
    - DOM 읽기 (코드 전체로 퍼짐 → 함수 안에 action 있으면 전체가 action으로 취급)
- 모든 코드가 action이면 함수형으로 변환 필요
- 모든 함수는 I/O 존재
    - 명시적 입출력: declared as param/return
    - 암묵적 입출력: 전역변수 읽기, 콘솔 찍기 등 (action임!!)
        - 부수효과 (주요기능 X), 제거 필요 (명시적으로 전환)
- 액션에서 계산 빼내기 (반복적, 점진적으로)
    1. extract subroutine (기존 코드에서 동작 변경 x, 그냥 분리만)
        - action담당 부분을 다른 함수로 분리함 (그래도 아직 action)
    2. 모든 입출력을 명시적으로 변경 
        - TIP: 직접 변경 대신 카피온라이트

### Chapter 5

- 또 모든 action은 버릴 수 없다.
- 코드의 냄새: 중복 코드
- 요구사항 잘 만족하는지 확인
- Action에서 암묵적 I/O 를 없애면 계산, 줄이면 더 나은 Action
    - 테스트가 쉬워진다 (아무때나 사용 가능)
- 전역변수 읽기를 인자로 추가함
- **계산 분류하기**: 엉켜있는 코드 풀기
- 함수는 작을수록 좋다. 재사용, 유지보수, 테스트에 좋음
- 분리는 어렵지만 합치기는 쉽다
- 하나에 대한 구조만 알게되게 분리 (copy-on-write 빼내기)
- 장바구니 기능 (보편적 기능) vs 비즈니스 규칙 (기업마다 다를 수 있으며 빠르게 바뀜)

### Chapter 6

- read: 데이터 변경 없이 정보 꺼내기 (인자에만 의존 시 계산)
- write: 데이터 안 바뀌는 **불변성 원칙** 필요
- JS는 따로 구현해주어야 한다 (PureScript라는 것도 있음)
- COPY-ON-WRITE (쓰기를 읽기로 바꾸기)
    1. make copy (외부에서 접근 불가) 
    2. change copied
    3. return changed copy
- 읽기 + 변경하는 작업 동시에 할 경우 ex: `.shift()`
    1. 읽기와 쓰기 각각 분리 (권장, 설계 = 엉켜 있는 것들 분리하는게 좋음, 또는 둘다 계산하고 조합)
    2. 값 두개 리턴
- copy-on-write 가 왜 읽기가 되는가
    - 쓰기 = 데이터 변경, 데이터를 복사하고 복붙 변경하기에 쓰기가 아니다
- 불변 데이터 읽기 ⇒ 계산! 
변경 데이터 읽기 ⇒ 액션
- 그래도 데이터 쓰기는 필요 (시간에 따라 변하는,  like 전역변수) ⇒ 교체하기
- 교체: 읽기, 바꾸기, 쓰기 ← 되돌리기 편하다
- 효율? 속도? 충분히 빠르다
    - 언제든 최적화 가능, GC도 빠름
    - 그렇게 많은 복사를 하지 않음 (얕은 복사만 하고 그 아래는 참조만 복사한다 (구조적 공유))
    - 함수형에는 더 빠른 구현체 존재함 (효율적, 초디ㅐ한 많은 구조를 공유해 더 적은 메모리 사용하고  GC 부담 줄임)
- 객체에 대한 copy on write
    - JS 는 slice로 객체 복사 불가 (`Object.assign({}, objectToCopy)`)
    - 얕은 복사, 즉 구조적 공유는 데이터가 불변시 안전함 (pg. 142참고)
- 중첩 복사 : 중첩된 하위 구조들까지 copy-on-write하기