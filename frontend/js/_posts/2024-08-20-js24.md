---
layout: post
title: Chapter 24 클로저
description: >
  Closures
categories: javascript
accent_color: "#D0C8B6"
accent_image:
  background: "#E2DAD5"
theme_color: "#D0C8B6"
sitemap: false
permalink: /frontend/js/chapter24
---

{:toc .large-only}

- 오 프언 리뷰느낌쓰,,
- JS 한정이 아니기에 ECMAScript 에 등장 X

> Closure = function + lexical environment of function (when declared) - MDN

### 24.1 렉시컬 스코프

- recap
  - JS Engine: 어디서 호출이 아닌, **어디에 정의되었는지에 따라 상위 스코프 결정**
  - $$\rightarrow$$ 정적 스코핑 (lexical/static scoping)

### 24.2 함수 객체의 내부 슬롯 [[Environment]]

- 함수 객체가 생성될 때, **함수가 정의된 환경**을 `[[Environment]]` 내부 슬롯에 저장
  - => 상위 스코프를 여기다 저장함
  - => 상위 스코프 참조 = **현재 실행 중인 실행 컨텍스트의 렉시컬 환경**, because 생성 시점에는 상위 함수가 평가/실행중이기 때문

### 24.3 클로저와 렉시컬 환경

```js
const x = 1;

function outer() {
  const x = 10;
  const inner = function () {
    console.log(x); // 평가식이기에 runtime에 실행됨
  };
  return inner;
}

const innerFunc = outer();
innerFunc(); // 10
```

- `outer`은 `inner`를 반환하고 (life cycle) 종료

  - `outer`의 실행 컨텍스트는 스택에서 `pop`
  - `x` 역시 생명주기 마감

- BUT, `inner`은 어떻게 `x` 접근 가능한가?

  - `outer`의 렉시컬 환경을 기억하고 있음
  - `inner`가 호출되면, `outer`의 렉시컬 환경을 참조하여 `x`를 찾음

- 📌 외부함수보다 중첩함수가 더 오래 유지되는 경우
  - 중첨함수는 이미 생명주기가 종료된 외부함수의 변수에 접근 가능
  - **이러한 중첩함수를 클로저라고 부름**

- WHY? 
  - 위 실행 컨텍스트가 스택에서 pop 되지만 **환경까지 소멸되는 것은 아님!**
  - `inner`의 `[[Environment]]`에 의해 참조 -> GC 대상 X

- 이론적으로 JS의 모든 함수는 클로저지만, 딱히 그렇게 부르진 않음