---
layout: post
title: 2023 July TIL
description: >
  30 minutes per day
categories: til
sitemap: false
accent_image: /assets/default.jpg
permalink: /til/July
pagination: false
---

- this list will be replaced by the toc
{:toc .large-only}

## 7/1: React-Query

---

- `react-query`는 서버의 값을 클라이언트에 가져오거나, 캐싱, 값 업데이트, 에러핸들링 등 **비동기 과정을 더욱 편하게** 하는데 사용됩니다.

- $$\Rightarrow$$ 서버, 클라이언트 데이터 분리
- **React Query 장점**:
  - 캐싱
  - `GET` 데이터에 대해 update 시 자동으로 `GET` 다시 수행
  - 데이터가 오래되었다고 판단되면 다시 `GET` (`invalidateQueries`)
  - 동일 데이터 여러번 요청들어오면 한번만 요청함 (옵션에 따라 중복 호출 허용 시간 조절 가능)
  - 무한 스크롤 (??)
  - 비동기 과정을 선언적으로 관리 가능 ([React Suspense](https://kyounghwan01.github.io/blog/React/react-query/basic/#react-suspense%E1%84%8B%E1%85%AA-react-query-%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5) 공부하기..)
  - React Hook와 유사

이렇게 보면 사용 안할 이유가 없어보인다. 단점들도 찾아봐야겠다.

### useQuery

---

> 데이터를 `GET` 하기 위해 사용

```js
useQuery(uniqueKey, api_call);
```

- `unique Key`: (string $$\mid$$ 배열) **다른 컴포에서 해당 키를 부르면 호출 가능**
  - (배열일 경우) 배열[0]: string, 배열[1]: query 함수 내부 parameter로 들어가 변수처럼 사용 가능
- `api_call`: 비동기 호출 함수, Promise가 들어가야 함
- `return`: api의 성공여부 또는 API return값을 포함한 객체

```js
const Members = () => {
  const { isLoading, isError, data, error } = useQuery("members", fetchMemberList, {
    refetchOnWindowFocus: false,
    retry: 0,
    onSuccess: data => console.log(data)
    onError: e => console.log(e.message); // API 호출 실패
  });

  if (isLoading) return <span>Loading...</span>
  if (isError) return <span>Error: {error.message}</span>

  return (
    <ul>
      {data.map(member => (
        <li key={member.id}>{member.name}</li>
      ))}
    </ul>
  );
};
```

- `refetchOnWindowFocus` : 사용자가 다른 창 갔다오면 함수 재실행 여부
- `retry`: 실패 시 재호출 횟수
- `onError`: HTTP에러가 아닌, 정말 api 호출이 실패한 경우만 호출 (강제로 에러 발생시키려면 api단에서 throw Error 날리기) [참고](https://react-query.tanstack.com/guides/query-functions#usage-with-fetch-and-other-clients-that-do-not-throw-by-default)

- `isLoading, isError` 말고 **_status로_** 한번에 처리 가능

```js
  const { status, data, error } = useQuery("members", fetchMemberList);

  if ( status === 'loading' ) ...
  if ( status === 'error' )...
```

- `useQuery`는 **_비동기로 작동_** $$\Rightarrow$$ 컴포 내에 여러개의 `useQuery` 존재 시 **한꺼번에 실행**됨 $$\rightarrow$$ `useQueries` 추천
- `enabled` 사용 시 동기적으로 사용 가능! (3rd parameter of `useQuery`)

```js
const { data: memberList, error, isFetching } = useQuery("members", fetchMemberList);
const { data: nextMember, error, isFetching } = useQuery("nextMembers", 
    fetchNextMemberList, {
      enabled: !!memberList, // true가 되면 fetchNextMemberList 실행
    });
```

### useQueries

---

- 여러 비동기적으로 실행되는 `useQuery`에 대해 모든 변수, 로딩, 성공, 실패처리를 해주어야 함
- `useQueries`: `promise.all` 처럼 `useQuery`를 하나로 묶기

```js
const queries = useQueries([
  { queryKey: "members", queryFn: fetchMembers },
  { queryKey: "conferences", queryFn: fetchConferences },
]);

useEffect(() => {
  console.log(result);
  const loadingFinishAll = result.some((result) => result.isLoading);
  console.log(loadingFinishAll); // loadingFinishAll이 false이면 최종 완료
}, [result]);
```

### uniqueKey 활용
***
- 배열에 unique key: query 함수 내부에서 변수로 사용 가능 (parameter로 들어감)

```js
const clubId = 1;
const result = useQueries([
  {
    queryKey: ["getMembers", clubId],
    queryFn: (params) => {
      console.log(params); // {queryKey: ['getMembers', 1 ], pageParam: undefined, meta: undefined}
      return api.getMembersInfo(clubId);
    },
  },
  {
    queryKey: ["getConference", clubId],
    queryFn: () => api.getConferenceInfo(clubId),
  },
]);
```

### QueryCache

---

> Query에 대해 성공, 실패 전처리

```js
const queryClient = new QueryClient({
  queryCache: new QueryCache({
    onError: (error, query) => {
      console.log(error, query);
      if (query.state.data !== undefined) {
        toast.error(`에러가 났어요!!: ${error.message}`);
      },
    },
    onSuccess: data => {
      console.log(data)
    }
  })
});
```

- 조금 더 공부할것...

### useMutation

---

> `POST`, `UPDATE` 용

- return: `useQuery`와 같음

```js
  const [id, setId] = useState("");
  const [password, setPassword] = useState("");

  const loginMutation = useMutation(loginApi, {
    onMutate: variable => {
      console.log("onMutate", variable); // variable : {loginId: 'xxx', password; 'xxx'}
    },
    onError: (error, variable, context) => {...} ///error
    onSuccess: (data, variables, context) => {
      console.log("success", data, variables, context);
    },
    onSettled: () => {
      console.log("end");
    }
  });

  const handleSubmit = () => {
    loginMutation.mutate({ loginId: id, password });
  };
```
- **Update 후 GET 재실행**: mutation 함수 성공 시 unique key로 매핑된 GET함수를 <cb>invalidateQueries</cb>에 넣어주기 
```js
const mutation = useMutation(postMember, {
  onSuccess: () => {
    // postMember이 성공하면 members로 맵핑된 useQuery api 함수를 실행합니다.
    queryClient.invalidateQueries("members");
  }
});
```
- mutation에서 return 된 값 이용해서 GET함수 params 바꿔주어야 할 경우: <cb>setQueryData</cb>

  ```js
  const queryClient = useQueryClient();

  const mutation = useMutation(editMember, {
    onSuccess: data => {
      queryClient.setQueryData(["member", { id: 5 }], data);  // data가 fetchMemberById 들어간다
    }
  });

  const { status, data, error } = useQuery(["member", { id: 5 }], fetchTodoById);

  mutation.mutate({
    id: 5,
    name: "TEST1"
  });
  ```

- 더 자세한 내용은: [노경환 깃헙](https://kyounghwan01.github.io/blog/React/react-query/basic/)

## 7/2: Recoil

- [KLUB](https://klub.kr/) 프로젝트 팀장님이 상태관리 라이브러리로 redux가 아닌 recoil 도입해 보자고 하셔서 급하게 공부! 

### RecoilRoot
***
- Facebook에서 개발함
- `npm i recoil` or `yarn add recoil`

- Recoil 상태를 활용하는 컴포넌트는 부모 컴포넌트 어딘가에 `RecoilRoot` 필요!! $$\rightarrow$$ root component에 추천

```js
import React from 'react';
import { RecoilRoot, atom, selector, useRecoilState, useRecoilValue } from 'recoil';

function App() {
  return (
    <RecoilRoot>
      <MyApp />
    </RecoilRoot>
  );
}
```
### Atom
***
**ATOM**: piece of **state**, 어느 컴포넌트에서든 읽기/작성 가능 
  - 해당 ATOM을 읽는 컴포넌트는 **암무적으로 종속**됨 $$\rightarrow$$ ATOM이 업데이트 될 때 관련된 모든 컴포넌트가 리렌더링 됨 

  ```js
  const textState = atom({
    key: 'textState', // unique ID
    default: '', // 초기값
  });
  ```
  - **읽기** + **쓰기** Atom 사용 시: <cb>useRecoilState()</cb>사용
  
  ```js
  const [text, setText] = useRecoilState(textState);
  ```

### Selector 
***
- piece of **derived state** (state의 **Transformation**, 즉 변형된 값)

```js
const charCountState = selector({
  key: 'charCountState', 
  get: ({get}) => {
    const text = get(textState);
    return text.length;
  },
});
```
- selector 값 읽을 때는 <cb>useRecoilValue</cb> hook 사용

```js
const count = useRecoilValue(charCountState);
```
### Recoil vs Redux
***

|                 | $$Recoil$$ | $$Redux$$ |
|:--------------- |:------|:------|
| 장점            | - React의 `useState`와 유사, **직관적이며 간단한 구조** <br/>- 코드의 양의 줄어듬 | - 가장 익숙한 상태관리 라이브러리 <br/> -검증된, 신뢰성 있음 <br/>- `Redux Devtools`로 상태값이 많아지면 보다 쉬운 디버깅 가능 |
| 단점            | - $$Redux$$처럼 따로 안정적인 Devtool 존재X. <br/> - `snapshot`이라는 개념 존재하지만 콘솔을 이용해 봐야 한다<br/>- Recoilize라는게 있는데 작은 버그들때문에 실제 사용자들은 콘솔을 선호하신다고 한다...! |- 작은 상태 하나 변경하려 해도 `actions`, `reducer`, `type` 등 보일러 플레이트 코드를 많이 작성해야 함 |
| 비동기처리 | - `Selector` 사용, 기본적으로 값을 캐싱 <br/>- 한번 들어왔었던 값을 기억하고 있음 $$\rightarrow$$ 같은 응답을 보내는 API CALL에 대해서는 추가요청X (성능적으로 좋음) <br/>`redux`처럼 따로 미들웨어 설치 필요X (내장되어 있음) | `redux-thunk`, `redux-saga`, `redux-toolkit` 등일 이용해 비동기 or 부가기능을 처리함 (검증된 미들웨어)

- 결론: 디버그의 측면에서는 redux가 더 유리하나, redux는 작성해야 하는 코드 양이 많아진다

### Jotai, Zustrand
***
- recoil은 (2022년 1월 기준) 매우 느리게 발전중, Jotai와 Zustand는 활발한 업데이트 이루어지는 중
- Recoil: `JS`, Jotai & Zustand: 100% `TS`

**JOTAI** [공식문서](https://jotai.org/)
- Context의 **리렌더링 문제를 해결하기 위해** 만들어진 React 특화 상태관리 라이브러리
  - `selectAtom`, `splitAtom`
- Recoil에 영감을 받아, atomic한 상태관리 방식으로 구성 (bottom-up 방식)
- Recoil과 다르게 `key` 불필요 (보일러 플레이트 코드 줄어듦)
- 보일러 플레이트 코드가 redux에 비하면 현저하게 줄어든다.
- 앞으로 React 의 주요 feature일 Suspense(Concurrent mode)를 적용하는데에 적합하게 설계되었다. <fade>모르는 내용, 공부 필요</fade>
- 강조점: 
  1. **PRIMITIVE**: React의 `useState`와 유사한 interface
  2. **FLEXIBLEE**: `atom`들끼리 서로 결합 및 상태에 관여 가능, 타 라이브러리들과 원활한 결합 지원

**ZUSTAND** [공식문서](https://github.com/pmndrs/zustand)

- 한번 사용해 봤는데, 굉장히 간단하게 상태관리 구성이 가능하다.
- 공식문서도 굉장히 짧다.

- 참고자료: [Recoil 공식문서](https://recoiljs.org/docs/introduction/getting-started/), [Neul_bo.log](https://velog.io/@ken1204/%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-Recoil-Redux), [개발자 아저씨들 힘을모아](https://programming119.tistory.com/263)


## 7/3: IT Terms 
***
- 최근에 자주 보인 단어들 복습 및 정리

### Bottleneck Effect
***

- **병목현상**
- 병의 목 부분처럼 넓은 길이 갑자기 좁아짐 $$\Rightarrow$$ 교통 정체 현상 
- 컴퓨터 성능 저하: 엄청난 양의 데이터를 순식간에 내보냄 BUT 메모리가 제대로 소화 불가 

### Adhoc
***
- 애드혹: "이것을 위해", "특별한 목적을 위해서" 
  - $$\Rightarrow$$ Specific-purpose

1. 특정한 문제나 일을 위해 만들어진 관습적인 해결책
2. 일반화할 수 없는 해결책
3. 어떤 다른 목적에 적응시킬 수 없는 해결책 

- **Ad-hoc Programming**: 코드를 특정 목적을 달성하기 위해서만 작성
- **Ad-hoc Database Queries**: 하드코딩

  ```sql
  SELECT * FROM employee WHERE id=101; # Adhoc
  SELECT * FROM employee WHERE id=@id; # params
  ```
- **Ad-hoc Coding**: 설계에 맞춰 개발하는 것이 아닌, 문제 분석 없이 개발에 뛰어드는 행위 
  - 주로 쉽게 짜여지나 유지보수하기 비효율적이며 Input cases의 일부만 커버함

- **Ad-hoc Testing**: 문서화X, 테스트디자인X, 테스트케이스X
  - 랜덤으로 일부만 테스트함 <fade>주로 시간 없을때 이렇게 됨</fade>

- 참고자료: [Baeldung CS](https://www.baeldung.com/cs/ad-hoc-programming)


### Boiler Plate
***

- 원래: 19세기에 증기 보일러 만들떄 틀로 사용하던 강철판, 제조정보가 음각으로 새겨져 있음 $$\Rightarrow$$ 인쇄 분야로 이어져 **반복해서 사용하는 텍스트** (광고/로고) 를 의미

- 컴퓨터 분야에서의 보일러플레이트: **변화없이 여러 군데에서 반복되는 코드**
  - JAVA에서 한 class 만들때 `getter`, `setter` 모두 정의 필요 

- 없어져야 하는 것이 아닌, ***최소한의 변경으로 재사용할 수 있는 코드***

- 참고자료: [프로그래밍 용어사전](https://www.wisewiredbooks.com/term-dict/common/boilerplate.html)

### Scaffolding

- 원래: 건축현장에서 외벽에 임시로 작업자들이 지나다닐 수 있도록 만든 구조물 
- 컴퓨터 프로그래밍에서의 의미:
  1. 초기 프로젝트의 뼈대 생성 
    - README, License, dir 구조, 컴파일 설정, 자동으로 생성하는 CLI, UI..
  2. 일부 MVC (Model-View-Controller) 프레임워크에서 사용하는 의미  
    - 개발자가 사용하고자 하는 모델을 정의하면 자동으로 관련된 보일러플레이트 코드가 만들어지는 기법
- 쉬운 예시:
  - $$React$$의 CRA (`create-react-app`)
  - $$Nest$$의 `nest new PROJECTNAME`
  - `C#`의 Visual Studio에서의 새 프로젝트 만들기
  - IntelliJ에서 Java Project 생성...etc

- 참고자료: [프로그래밍 용어사전](https://www.wisewiredbooks.com/term-dict/common/scaffolding.html)

### Bootstrap, Bootstrapping

- Boot + Strap (부츠 뒷 부분에 달린 끈 혹은 고리) 합성어
> to pull oneself up by one's bootstraps

- 신발을 신은 채로 자신의 신발의 부트스트랩으로 자신을 들어올린다는 뜻 
- 불가능하다는 의미였지만 현재는 **자력으로 일을 해낸다는 의미**로 변형
- 컴퓨터 분야: 한번 시작하면 외부 도움 없이 스스로 진행하는 행위를 통틀어 칭함

**부팅**: Bootstrapping의 줄임말 
- 전원을 켜는 행위에서 그치는 것이 아닌, BIOS (Basic I/O) 도 포함 (전원 켜질 시 진행)
1. 전원 ON 
2. BIOS에서 `CPU`, `Memory` 등의 주변 HW 진단 
3. 부팅매체 (Hard Disk)의 $$MBR$$ (Master Boot Record)에 저장된 부트로더 (Bootloader, aka Bootstrap Code) 프로그램을 `Memory`로 복사 
4. Bootloader Takes Control : Disk에 있는 OS의 코드를 메모리에 올려서 OS 실행
5. OS Takes Control

- $$\Rightarrow$$ OS는 셀프 실행 불가 **BUT 실행만 되면 외부 도움 없이 컴퓨터 완벽제어**

**컴파일러**
- 스스로 컴파일할 수 있는 컴파일러를 만들어 나가는 과정 
- 특정 프언을 만들떄 반드시 컴파일러도 만듦. BUT _초기에는 다른 언어로_ 그 컴파일러를 만든다
- `Python`, `Java`, `C#`, `C++` 등 대부분 주요 언어에서는 부트스트래핑 과정을 거쳐서 자신의 언어로 컴파일러 생성됨 
- 주요 장점:
  1. 컴파일할 언어로 작성하기 때문에 중요한 테스트가 된다
  2. 컴파일러 개발자들은 컴파일 할 언어만 알면 된다
  3. 컴파일될 고급 언어로 컴파일러 개발이 가능하다 (보통 저급언어로 고급언어 컴파일러 만드는 경우가 많기 때문)


- 참고자료: [프로그래밍 용어사전](https://www.wisewiredbooks.com/term-dict/common/bootstrap.html)

## 7/4: Rest

~~뭔지 제대로 알아보지도 않고 6개월간 쓰고 있었음을 인지...~~ 자주 사용하던거라서 그래도 쉽게 읽혔다. 이렇게 사용은 해봤는데 이론이 부족한 부분이 많은 것 같다. 그래도 찝찝했던거 하나씩 짚고 넘어가서 기분이 좋당
{:.note}

> REST: **Representational State Transfer**
{:.lead}


![Full-width image](https://gmlwjd9405.github.io/images/network/rest.png){:.lead width="800" height="100" loading="lazy"}

HeeJeong Kwon Github
{:.figcaption}

### REST의 개념 

- **자원의 이름으로 구분**하여 **정보를 주고 받는** 모든것을 의미 
  - 자원: DB = 학생정보 $$\rightarrow$$ 자원 = `students`
  - 정보: 데이터 요청 시점에서 자원의 상태 (정보) 전달 (주로 $$JSON$$ 또는 $$XML$$)

- **SW 개발 Architecture**의 한 종류 (`www` 같은 분한 하이퍼미디어 시스템을 위한)
- 기본적으로 웹의 기존 기술과 `HTTP` 프로토콜을 그대로 활용하기 때문에 **웹의 장점을 최대한 활용할 수 있는 아키텍쳐 스타일**
- 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나
- 구체적인 개념: 
  > HTTP URI (uniform resource identifier)을 통해 자원 (resource) 을 명시하고 HTTP Method (`POST`, `GET`, `PUT`, `DELETE` ) 를 통해 자원에 대한 CRUD Operation을 적용

### REST의 장단점 

| 장점 | 단점 | 
| :--- | :----| 
| - HTTP 프로토콜의 인프라 그대로 사용, 별도 인프라 구축X <br/>- HTTP 프르토콜의 표준을 최대한 활용 -> 장점도 흡수 <br/>- HTTP표준의 모든 플랫폼에서 사용 가능 <br/>- Hypermedia API의 기본 충실히 지키며 범용성 보장 (??) <br/>- 명확하므로 쉽게 의도 파악 가능 <br/>- 서버와 클라 역할을 명백하게 분리| - 표준이 존재하지 않는다 <br/>- 사용할 수 있는 메소드가 4가지 밖에 없다 <br/>- 브라우저를 통해 테스트할 일이 많은 서비스라면 Header값이 URL보다 더 어렵게 느껴진다 <br/>- 구형 브라우저가 아직 제대로 지원불가한 부분 존재 (`PUT`, `DELETE`, `pushState` 지원X) |


- **REST가 필요한 이유**
  - 애플리케이션 분리 및 통합 
  - 다양한 클라이언트의 등장
  - 다양한 브라우저와 모바일 디바이스에서까지 통신 가능

### REST 구성 요소

1. 자원 (Resourec): URI
  - 모든 자원에 고유한 ID 존재, SERVER에 존재
  - 자원 구별하는 ID는 HTTP URI (ex: `/members/:memberId`)
  - Client: URI이용해서 자원 지정 $$\rightarrow$$ 자원의 상태에 대한 조작을 Server에 요청 

2. 행위 (Verb): HTTP Method
3. 표현 (Representation of Resource)
  - 서버가 클라의 요청에 따라 적절한 응답 (Representation) 발송

### REST 특징 
1. **Server-Client 구조** (자원이 있는 쪽이 Server, 요청하는 쪽이 Client)
  - REST Server: API제공, 비즈니스 로직 처리 및 저장
  - Client: 사용자 인증이나 context(세션, 로그인 정보)등을 직접 관리하고 책임짐
  - $$\Rightarrow$$ 서로간 의존성 저하

2. **Stateless** (무상태)
  - <fade>무상태성이란? does not save client data generated in one session for use in the next session with that client (독립적인 트랜잭션으로 취급)</fade>
  - HTTP는 Stateless Protocol이므로 REST역시 무상태성 
  - Client의 context를 Server에 저장 X $$\rightarrow$$ 구현 단순화
  - Server은 각각의 요청을 완전히 별개의 것으로 인식 후 처리 
    - 일관성 부여, 자유도 높아짐 

3. **Cacheable**
  - HTTP의 특성 중 하나 (Last-Modfied / E-Tag 으로 캐싱 구현 가능)
  - 대량의 요청을 효율적으로 처리하기 위해 필요
  - 응답시간 빨라짐, REST Server 트랜잭션 발생X $$\Rightarrow$$ 전체 응답시간, 성능, 서버의 자원 이용률 향상

4. **Layered System** (계층화)
  - Client는 REST API Server만 호출
  - REST Server은 다중 계층 구성 가능 
    - API Server은 순수 비즈니스 로직 수행
    - 그 앞단에 보안, 로드밸런싱, 암호화, 사용자 인증 추가 가능 (구조상 유연성)
  - PROXY, Gateway같은 네트워크 기반의 중간 매체 사용 가능

5. **Code-On-Demand** (optional)
  - Server로부터 스크립트를 받아서 Client에서 실행 (반드시 충족X)

6. **Uniform Interface** (인터페이스 일관성)
  - URI로 지정한 Resource에 대한 조작을 통일/한정적인 Interface로 수행
  - HTTP 표준 프로토콜에서 따르는 모든 플랫폼에서 사용 가능 (특정 언어나 기술에 종속X)


희정님 깃헙이 정리가 매우 잘 돼 있다. 이분 깃헙 페이지 공부하는 것도 많은 도움이 될듯 싶당
API 분리를 하면서 리팩토링하는 테스크에서 선배들이 한 프로젝트의 부분 보면 `PATCH`도 같이 사용하던데 이것도 정확히 뭔지 알아봐야겠다. 아 그리고 컴네 복습 해야겠다...
{:.note}

- 참고자료: [HaeeJeong Github](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)


## 7/6: Error Boundary

### 장점 & 필요한 이유

이것도 프로젝트에 도입한다고 해서 급하게 공부해봤다. 선언형 프로그래밍이 익숙하지 않아 내일쯤 TIL로 해봐야겠다..Error 처리 중 중복되는 코드들이 보기 싫었는데 뭔가 해결책일 것 같아 흥미롭게 공부해본다
{:.note}

- React 16에서 도입된 컨셉, 쉽고 효과적으로 에러처리 가능 
  - 카카오페이지에서는 Fetcher 컴포넌트로 API 호출, Error Boundary로 비동기에서 에러 관리
  - <fade>Fetcher 컴포넌트는 React 18의 Suspense 컴포넌트에서 derived, 호출/상태관리 가능, 선언형으로 사용 가능...TIL에서 두번 나온 내용인데 꼭 공부해봐야겠다</fade>

- 전에 사용하던 방식 ( Error 상태 관리 $$\leftarrow$$ 에러 발생하면 에러메시지 보여주는 컴포넌트 렌더링 ) 의 **고민** 과 Error Boundary가 해결 가능한 것들: 
  1. 선언적으로 에러 처리 방법 (like Fetcher)
  2. 서버점검, 네트워크 에러 같은 공통 에러 한곳에 처리
  3. (For better UX) 에러 발생 시 컴포넌트에서 유저가 API 호출을 재시도하여 에러를 리셋할 수 있는 트리거 배치
  4. 렌더링 중 TypeError 과 같은 예상치 못한 런타임 에러 <fade>JS 로 작성한 것 같다</fade>

~~<fade>2번빼고 모르겠다...</fade>~~

### Error Boundary로 에러 처리

> Error Boundary: **하위 컴포넌트 트리**에서 발생한 에러를 잡아서 **선언적으로 처리**할 수 있는 컴포넌트
{:.lead}

- $$\Rightarrow$$ 상위 컴포넌트를 `<ErrorBoundary>`로 Wrap하기
  - 물론 최상위 컴포넌트만 묶는게 아니다. 필요한 컴포넌트들의 상위에 적절히 배치하여 사용
- 공식문서를 보다가 알게 된 사실인데, <cb>function component로는 Error Boundary 작성이 불가능</cb>하다 (`static required`)

```js 
//App.js
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI.
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return this.props.fallback;
    }

    return this.props.children;
  }
}
...
<ErrorBoundary>
  <ExampleApplication/>
</ErrorBoundary>
```

- Rendering 중 throw된 error을 `catch` 하도록 동작함
- `static getDerivedStateFromError`: lets you display error message instead of clearing the UI (주로 `componentDidCatch` 와 동시 사용)

### react-error-boundary

- function 정의 가능!

`npm i react-error-boundary` or `yarn add react-error-boundary`

```js
import { ErrorBoundary } from "react-error-boundary";

<ErrorBoundary fallback={<div>Something went wrong</div>}>
  <ExampleApplication />
</ErrorBoundary>
```
- **fallback** prop에 정의된 함수 추가

```js
import { ErrorBoundary } from "react-error-boundary";

function fallbackRender({ error, resetErrorBoundary }) {
  // Call resetErrorBoundary() to reset the error boundary and retry the render.
  return (
    <div role="alert">
      <p>Something went wrong:</p>
      <pre>{error.message}</pre>
    </div>
  );
}

<ErrorBoundary
  fallbackRender={fallbackRender}
  onReset={(details) => {
    // Reset the state of your app so the error doesn't happen again
  }}
>
  <ExampleApplication />
</ErrorBoundary>;
```

- ***`useErrorBoundary`*** Hook : shows nearest error boundary from event handler (Dismiss도 가능)
  ```js
  import { useErrorBoundary } from "react-error-boundary";

  function Example() {
    const { showBoundary } = useErrorBoundary();

    useEffect(() => {
      fetchGreeting(name).then(
        response => {
          // Set data in state and re-render
        },
        error => {
          // Show error boundary
          showBoundary(error);
        }
      );
    });
  }
  ```

- ***ErrorBoundary cannot be used as a JSX component***

- 참고자료: [카카오 FE 기술블로그](https://fe-developers.kakaoent.com/2022/221110-error-boundary/), [React dev](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary), [react-error-boundary](https://github.com/bvaughn/react-error-boundary)


## 7/7: Rest Api
***
~~Rest 하다가 너무 길어져서..이어서 쓴다~~.
올해 해커톤에서 처음으로 API라는걸 보았는데, 팀장님이 각자 API명세서를 써오라고 하셔서 진짜 막막했던 기억이 있다. 근데 해보니 별거 아니었다ㅋㅋ물론 나중에 싹 갈아엎어야 했지만...쫄지말자 일단 하면 된다.
아 그리고 뭔가 프로젝트 공부에 연장선인 것 같은데 백엔드 팀이 API uri를 Restful하게 (더?) 바꾼다고...해서 뭔지 알아볼 필요는 있다!
{:.note}

- API (Application Programming Interface) : 
  데이터와 기능의 집합을 제공, 컴퓨터 프로그램 간 상호작용 촉진, 정보 교환 가능하도록 함
- **REST API** (Representational State Transfer API)
  REST 기반 API

- 최근 OpenAPI <fade>( Google Maps, 공공데이터 etc) </fade>, 마이크로 서비스 <fade>( architecture that a big application is divided into small applications that can be changed, combined..etc )</fade> 대부분 REST API제공

- 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용이 편리 
- HTTP를 지원하는 언어로 클라/서버 구현 가능

### 설계 기본 규칙 
***

- Resource 원형
  - DOCUMENT: obj instance 나 DB record와 유사한 개념
  - COLLECTION: 서버에서 관리하는 Directory라는 RESOURCE
  - STORE: 클라이언트에서 관리하는 RESOURCE 저장소

1. URI는 정보의 자원을 표현
  - RESOURCE: **명사, 소문자**
  - DOCUMENT 이름으로는 단수 명사 사용 
  - COLLECTION, STORE 이름으로는 복수 명사 사용
    - ex: `GET /Member/1` $$\rightarrow$$ `GET /members/1`

2. 자원에 대한 행위는 HTTP Method 로 표현
  - Uri에 method가 들어가면 안됨 (`GET /members/delete/1` $$\rightarrow$$ `DELETE /members/1`)
  - 행위에 대한 동사 표현 금지 (CRUD 나타내기X)
    - `GET /members/show/1` $$\rightarrow$$ `GET /members/1`
    - `GET /members/insert/2` $$\rightarrow$$ `POST /members/2`
  - 경로에 변경가능성 있는 부분은 unique 값으로 대체 (`:id`)
    - 

### REST API 설계 규칙
***

1. `/` : used to show 계층 관계
2. URI 마지막에 `/` 포함 X
3. `-` : used to enhance readability
4. `_` : NOT USED
5. use lowercase letters (RFC 2986, URI문법 형식은 URI스키마와 호스트 제외 대소문자 구별하도록 규정)
6. NO extensions in Uri, but uses **Accept header**
  - WRONG: `http://restapi.example.com/members/soccer/345/photo.jpg`
  - CORRECT: `GET / members/soccer/345/photo HTTP/1.1 Host: restapi.example.com Accept: image/jpg`
7. If resources have relationships: 
  - `리소스명/리소스ID/다른리소스`
  - ex: `/users/{userid}/devices`

### RESTful의 개념
***
- RESTful: follows REST 개념 
- **목적**: 이해하기 쉽고 사용하기 쉬운 REST API 만들기 (일관적인 컨벤션으로 호환성, 이해도 향상)
- RESTful하지 못한 경우:
  - CRUD기능을 모두 POST로만 처리하는 API
  - route에 resource, id외의 정보가 들어가는 경우 (/students/updateName)


대문자가 들어가면 안된다는건 처음 알았다. 여태 `clubId`, `memberId` 이렇게 했는데 싹 다 바꾸고 있겠구나 싶다..
{:.note}

- 참고자료: (역시나) [HaeeJeong Github](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)