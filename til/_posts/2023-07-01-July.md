---
layout: post
title: 2023 July TIL
description: >
  30 minutes per day
sitemap: false
accent_image: /assets/default.jpg
permalink: /til/2023/July
pagination: false
---

- this list will be replaced by the toc
{:toc .large-only}

## 7/1: React-Query

---

- `react-query`는 서버의 값을 클라이언트에 가져오거나, 캐싱, 값 업데이트, 에러핸들링 등 **비동기 과정을 더욱 편하게** 하는데 사용됩니다.

- $$\Rightarrow$$ 서버, 클라이언트 데이터 분리
- **React Query 장점**:
  - 캐싱
  - `GET` 데이터에 대해 update 시 자동으로 `GET` 다시 수행
  - 데이터가 오래되었다고 판단되면 다시 `GET` (`invalidateQueries`)
  - 동일 데이터 여러번 요청들어오면 한번만 요청함 (옵션에 따라 중복 호출 허용 시간 조절 가능)
  - 무한 스크롤 (??)
  - 비동기 과정을 선언적으로 관리 가능 ([React Suspense](https://kyounghwan01.github.io/blog/React/react-query/basic/#react-suspense%E1%84%8B%E1%85%AA-react-query-%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5) 공부하기..)
  - React Hook와 유사

이렇게 보면 사용 안할 이유가 없어보인다. 단점들도 찾아봐야겠다.

### useQuery

---

> 데이터를 `GET` 하기 위해 사용

```js
useQuery(uniqueKey, api_call);
```

- `unique Key`: (string $$\mid$$ 배열) **다른 컴포에서 해당 키를 부르면 호출 가능**
  - (배열일 경우) 배열[0]: string, 배열[1]: query 함수 내부 parameter로 들어가 변수처럼 사용 가능
- `api_call`: 비동기 호출 함수, Promise가 들어가야 함
- `return`: api의 성공여부 또는 API return값을 포함한 객체

```js
const Members = () => {
  const { isLoading, isError, data, error } = useQuery("members", fetchMemberList, {
    refetchOnWindowFocus: false,
    retry: 0,
    onSuccess: data => console.log(data)
    onError: e => console.log(e.message); // API 호출 실패
  });

  if (isLoading) return <span>Loading...</span>
  if (isError) return <span>Error: {error.message}</span>

  return (
    <ul>
      {data.map(member => (
        <li key={member.id}>{member.name}</li>
      ))}
    </ul>
  );
};
```

- `refetchOnWindowFocus` : 사용자가 다른 창 갔다오면 함수 재실행 여부
- `retry`: 실패 시 재호출 횟수
- `onError`: HTTP에러가 아닌, 정말 api 호출이 실패한 경우만 호출 (강제로 에러 발생시키려면 api단에서 throw Error 날리기) [참고](https://react-query.tanstack.com/guides/query-functions#usage-with-fetch-and-other-clients-that-do-not-throw-by-default)

- `isLoading, isError` 말고 **_status로_** 한번에 처리 가능

```js
  const { status, data, error } = useQuery("members", fetchMemberList);

  if ( status === 'loading' ) ...
  if ( status === 'error' )...
```

- `useQuery`는 **_비동기로 작동_** $$\Rightarrow$$ 컴포 내에 여러개의 `useQuery` 존재 시 **한꺼번에 실행**됨 $$\rightarrow$$ `useQueries` 추천
- `enabled` 사용 시 동기적으로 사용 가능! (3rd parameter of `useQuery`)

```js
const { data: memberList, error, isFetching } = useQuery("members", fetchMemberList);
const { data: nextMember, error, isFetching } = useQuery("nextMembers", 
    fetchNextMemberList, {
      enabled: !!memberList, // true가 되면 fetchNextMemberList 실행
    });
```

### useQueries

---

- 여러 비동기적으로 실행되는 `useQuery`에 대해 모든 변수, 로딩, 성공, 실패처리를 해주어야 함
- `useQueries`: `promise.all` 처럼 `useQuery`를 하나로 묶기

```js
const queries = useQueries([
  { queryKey: "members", queryFn: fetchMembers },
  { queryKey: "conferences", queryFn: fetchConferences },
]);

useEffect(() => {
  console.log(result);
  const loadingFinishAll = result.some((result) => result.isLoading);
  console.log(loadingFinishAll); // loadingFinishAll이 false이면 최종 완료
}, [result]);
```

### uniqueKey 활용
***
- 배열에 unique key: query 함수 내부에서 변수로 사용 가능 (parameter로 들어감)

```js
const clubId = 1;
const result = useQueries([
  {
    queryKey: ["getMembers", clubId],
    queryFn: (params) => {
      console.log(params); // {queryKey: ['getMembers', 1 ], pageParam: undefined, meta: undefined}
      return api.getMembersInfo(clubId);
    },
  },
  {
    queryKey: ["getConference", clubId],
    queryFn: () => api.getConferenceInfo(clubId),
  },
]);
```

### QueryCache

---

> Query에 대해 성공, 실패 전처리

```js
const queryClient = new QueryClient({
  queryCache: new QueryCache({
    onError: (error, query) => {
      console.log(error, query);
      if (query.state.data !== undefined) {
        toast.error(`에러가 났어요!!: ${error.message}`);
      },
    },
    onSuccess: data => {
      console.log(data)
    }
  })
});
```

- 조금 더 공부할것...

### useMutation

---

> `POST`, `UPDATE` 용

- return: `useQuery`와 같음

```js
  const [id, setId] = useState("");
  const [password, setPassword] = useState("");

  const loginMutation = useMutation(loginApi, {
    onMutate: variable => {
      console.log("onMutate", variable); // variable : {loginId: 'xxx', password; 'xxx'}
    },
    onError: (error, variable, context) => {...} ///error
    onSuccess: (data, variables, context) => {
      console.log("success", data, variables, context);
    },
    onSettled: () => {
      console.log("end");
    }
  });

  const handleSubmit = () => {
    loginMutation.mutate({ loginId: id, password });
  };
```
- **Update 후 GET 재실행**: mutation 함수 성공 시 unique key로 매핑된 GET함수를 <cb>invalidateQueries</cb>에 넣어주기 
```js
const mutation = useMutation(postMember, {
  onSuccess: () => {
    // postMember이 성공하면 members로 맵핑된 useQuery api 함수를 실행합니다.
    queryClient.invalidateQueries("members");
  }
});
```
- mutation에서 return 된 값 이용해서 GET함수 params 바꿔주어야 할 경우: <cb>setQueryData</cb>

  ```js
  const queryClient = useQueryClient();

  const mutation = useMutation(editMember, {
    onSuccess: data => {
      queryClient.setQueryData(["member", { id: 5 }], data);  // data가 fetchMemberById 들어간다
    }
  });

  const { status, data, error } = useQuery(["member", { id: 5 }], fetchTodoById);

  mutation.mutate({
    id: 5,
    name: "TEST1"
  });
  ```

- 더 자세한 내용은: [노경환 깃헙](https://kyounghwan01.github.io/blog/React/react-query/basic/)
