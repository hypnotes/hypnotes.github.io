---
layout: post
title: 2024 July TIL
description: >
  30 minutes per day
categories: til
sitemap: false
accent_image: /assets/default.jpg
permalink: /til/2024/July
pagination: false
---

- this list will be replaced by the toc
  {:toc .large-only}

## 7/22: Type vs Interface

---

> 회사에서 `interface` 금지하는 컨벤션이 궁금해졌다

**_Similarities_**

1. 객체 shape
2. index signature 가능

```js
interface IObj {
  [key: string]: any;
}

type TObj = {
  [key: string]: any,
};
```

**_Differences_**

1. Declaration Merging (선언 병합)

   - `interface`는 선언 병합 가능
   - `type`은 불가능

   ```js
   interface User {
     name: string;
   }

   interface User {
     age: number;
   }

   // Merged into: interface User { name: string; age: number; }

   type UserType = {
     name: string,
   };

   type UserType = {
     age: number,
   }; // Error: Duplicate identifier 'UserType'.
   ```

2. `type` complex 가능 (unions, intersections, mapped types etc)

   ```js
   type Status = "success" | "error" | "pending";

   type UnionType = User | UserType;

   type PartialUser = Partial<UserType>;
   ```

3. Inheritance

   - `type`: `&` 사용 (intersection)
   - interface: `extends` 사용

4. Primitive Alias (TYPEONLY)

   - `type`은 primitive type alias 가능

   ```js
   type Name = string;
   ```

5. Function Types: (type이 더 concise)

   ```js
   type Add = (a: number, b: number) => number;

   interface IAdd {
     (a: number, b: number): number;
   }
   ```

6. Tuple Types

   - `type`만 가능

   ```js
   type Tuple = [number, string];
   interface TupleInterface {} // Not applicable for tuples.
   ```

| Interface                                                       | Type                                          |
| --------------------------------------------------------------- | --------------------------------------------- |
| 다른 interface/clases 에 의해 extension, implementation 필요 시 | complex type def                              |
| ideal for API contracts                                         | when felxible, maipulative types are required |

## 7/23: Named vs Default Export

- [Treeshaking](https://webpack.js.org/guides/tree-shaking/) (tree shaking): dead code 제거

- Named Export (`import {a, b, c} from 'abc'` ) 

  - 이름이 정해져 있어 consistency 유지에 좋음 (물론 renaming 가능)
  - bundler (ex: Webpack) 이 treeshaking 할 때 좋다 (final bundle에 미사용 코드 제거)

- Default Export (`import abc from 'abc'` ) 

  - import 시 이름 정해야 함 (flexibility)
  - airbnb js styled guide: 하나만 export할 때는 `default` 사용
  - tree shaking 시 named export 보다 더 어려움


1. [What is the benefit of prefer-default-export](https://github.com/airbnb/javascript/issues/1365?source=post_page-----38fa5d7f57d4--------------------------------)
2. [Why and when to use default export over named exports in es6 Modules](https://stackoverflow.com/questions/46913851/why-and-when-to-use-default-export-over-named-exports-in-es6-modules)
